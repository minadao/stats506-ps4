---
title: "STATS 506 - Problem Set 4"
author: "Mina Dao"
format: html
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading Packages

```{r, warning = FALSE, message = FALSE}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(nzelect)
library(infer)
library(scales)
```

## Problem 1 - Tidyverse: New Zealand

```{r}
# load datasets
data(nzge, package = "nzelect")
head(nzge)
```

#### a. Generate a table of vote count per year/type

```{r}
voting_summary <- nzge %>% 
  group_by(election_year, voting_type) %>%
  summarise(
    total_votes = sum(votes, na.rm = TRUE), .groups = 'drop'
  ) %>% 
  arrange(desc(total_votes)) %>%
  select(election_year, voting_type, total_votes)
voting_summary
```

#### b. 2014 election, report proportion of votes for each party in the Candidate election

```{r}
candidate_vote_2014 <- nzge %>% 
  filter(election_year == 2014 & voting_type == "Candidate") %>%
  group_by(party) %>%
  summarise(total_votes = sum(votes, na.rm = TRUE)) %>% 
  mutate(
    total_all_parties = sum(total_votes),
    percentage = round(total_votes / total_all_parties * 100.0, 3)
  ) %>% ungroup %>%
  select(party, total_votes, percentage) %>%
  arrange(desc(percentage))
candidate_vote_2014
```

#### c. For each year, party won the Candidate vote, and party won the Party vote

```{r}
win_party_by_year <- nzge %>% 
  group_by(election_year, voting_type, party) %>%
  summarise(total_votes = sum(votes, na.rm = TRUE)) %>% 
  mutate(
    total_all_parties = sum(total_votes),
    percentage = round(total_votes / total_all_parties * 100.0, 2),
  ) %>%
  slice_max(percentage) %>%
  ungroup %>%
  select(election_year, voting_type, party) 

win_party <- win_party_by_year %>%
  pivot_wider(
    names_from = voting_type,
    values_from = party
  ) %>% arrange(election_year)

win_party
```

## Problem 2 - Tidyverse: Tennis

```{r}
tennis <- read.delim2("https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_matches_2019.csv", sep = ",")
head(tennis, 10)
```

I assume that `tourney_date` is the start date of that tournament, so tourney that starts on `20181231` ends in 2019. 

#### a. Number of tournaments in 2019

```{r}
num_tournaments <- tennis %>% 
  summarise(num_tournaments = n_distinct(tourney_id))
num_tournaments
```
We see that each tourney has a unique `tourney_id`, so we will count the number of unique `tourney_id`, and it is the number of tournaments which took place in 2019. There are 128 tournaments.

#### b. Multi-win players

```{r echo = FALSE}
# players with more than 1 win
multi_win_player <- tennis %>%
  group_by(tourney_id) %>%
  filter(round == "F") %>%
  filter(!is.na(winner_name)) %>%
  group_by(winner_name) %>%
  summarise(num_win = n(), .groups = 'drop') %>%
  filter(num_win > 1) %>%
  arrange(desc(num_win)) 
multi_win_player

# number of players who won more than 1 tournament
num_multi_win <- multi_win_player %>% nrow()
num_multi_win

# number of tournaments most winning player(s) won
num_most_win <- multi_win_player %>% slice_max(num_win)
num_most_win
```


I saw that the first-listed match of each tournament is the final match of that tournament where `round = F` (final), so the winner of that match is the winner of the whole tournament. Then we will count the number of tournaments each winner won.

There are 12 players who won more than one tournament. The most winning players won 5 tournaments.


#### c. Is there any evidence that winners have more aces than losers? 

```{r}
aces_compare <- tennis %>%
  filter(!is.na(w_ace) & !is.na(l_ace)) %>%
  select(w_ace, l_ace) 

aces <- aces_compare %>%
  pivot_longer(
    cols = c(w_ace, l_ace),
    names_to = "group",
    values_to = "ace_count"
  )

infer_test <- aces %>%
  t_test(
    response = ace_count,
    explanatory = group,
    order = c("w_ace", "l_ace")
  )
infer_test
```
We got p-value = $2.06 \times 10^{-26}$. We support that on average, winners have more aces than losers, with an estimated difference of $1.7$ aces.


#### d. Player(s) with the highest win-rate. Restrict to players with at least 5 matches.

```{r}
highest_win_rate <- tennis %>%
  # gather all matches for each player (both as winner and loser)
  pivot_longer(
    cols = c(winner_name, loser_name),
    names_to = "result",
    values_to = "player_name"
  ) %>% 
  mutate(win = ifelse(result == "winner_name", 1, 0)) %>%
  group_by(player_name) %>%
  summarise(
    match_played = n(),
    wins = sum(win),
    win_rate = round(wins / match_played * 100, 2),
    .groups = 'drop'
  ) %>% 
  filter(match_played >= 5) %>%
  slice_max(win_rate) 
highest_win_rate
```
We need to reshape the players' names into a column, so we use `pivot_longer`. The player with the highest win-rate is Rafael Nadal with a win-rate of $86.96\%$, $60$ wins out of $69$ matches played.

#### Problem 3: Visualization

```{r}
# read data
covid_data <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv")

# direct download of Census population estimates
census_url <- "https://www2.census.gov/programs-surveys/popest/datasets/2020-2023/state/totals/NST-EST2023-ALLDATA.csv"
state_populations <- read.csv(census_url) %>%
  filter(STATE != 0) %>%  # remove US total
  rename(
    state = NAME,
    population = POPESTIMATE2023
  ) %>%
  select(state, population)

# filter COVID data to only include 50 states + DC (exclude territories)
states_dc <- state_populations %>%
  select(state)
covid_data_states <- covid_data %>%
  filter(state %in% states_dc)

# convert date and ensure proper formatting
covid_data <- covid_data %>%
  mutate(date = ymd(date)) %>%
  arrange(date)

# convert numeric columns from character to numeric
covid_data <- covid_data %>%
  mutate(across(c(cases_avg, cases_avg_per_100k, deaths_avg, 
                  deaths_avg_per_100k), 
                as.numeric))

covid_data <- covid_data %>% arrange(date)

# merge population data and calculate cases per 100k
covid_data <- covid_data %>% 
  left_join(state_populations, by = "state") %>%
  mutate(cases_per_100k = (cases_avg / population) * 100000)

```
I chose to account for 50 states + DC, and not the US territories.

#### a. Major and minor spikes

```{r, warning = FALSE, fig.width=8, fig.height=6}
us_states_date <- covid_data%>%
  group_by(date) %>%
  summarise(total_cases = sum(cases))
  
us_states_week <- covid_data %>%
  mutate(week = floor_date(date, "week")) %>%
  group_by(week) %>%
  summarise(cases_week_avg = sum(cases) / 7)

p1 <- ggplot(us_states_date, aes(x = date, y = total_cases)) +
  geom_point(color = "gray60", alpha = 0.5, size = 0.8, shape = 16) +
  geom_line(data = us_states_week, 
            aes(x = week, y = cases_week_avg, color = cases_week_avg), 
            linewidth = 1.2, alpha = 0.9) +
  scale_color_viridis_c(
    option = "inferno", 
    direction = -1,
    name = "Average Cases Per Week") +
  labs(
    title = "COVID-19 Cases in the United States: Major and Minor Spikes",
    x = NULL,
    y = "Average Cases Per Week",
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    legend.title.position = "top",
    legend.key.width = unit(3, "cm")
  ) +
  scale_y_continuous(labels = comma)

p1
```
We can detect 1 major spike and 3 minor spikes.


#### b. States with highest and lowest overall rates per population: 


```{r warning = FALSE}
p2 <- ggplot(covid_data, aes(x = date, y = cases_per_100k, group = state)) +
  geom_line(color = "gray80", alpha = 0.3, linewidth = 0.4) +

  geom_line(data = covid_data %>% 
              group_by(state) %>%
              summarize(max_rate = max(cases_per_100k, na.rm = TRUE)) %>%
              arrange(desc(max_rate)) %>%
              slice(1:3) %>%  
              inner_join(covid_data, by = "state"),
            aes(color = "States with Highest Rates"), linewidth = 1.2) +
  
  geom_line(data = covid_data %>% 
              group_by(state) %>%
              summarize(max_rate = max(cases_per_100k, na.rm = TRUE)) %>%
              arrange(max_rate) %>%
              slice(1:3) %>%  
              inner_join(covid_data, by = "state"),
            aes(color = "States with Lowest Rates"), linewidth = 1.2) +
  
  scale_color_manual(
    values = c("States with Highest Rates" = "hotpink", 
               "States with Lowest Rates" = "dodgerblue3"),
    labels = c("Top States" = "Potentially Highest Rates", 
               "Bottom States" = "Potentially Lowest Rates")
  ) +
  
  labs(
    title = "COVID-19 Case Rates: All 50 States + DC",
    subtitle = "Red: Potential highest rate states | Blue: Potential lowest rate states | Gray: All others",
    x = NULL,
    y = "Average Cases per 100k"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10),
    legend.position = "bottom"
  ) +
  scale_y_continuous(labels = comma)
p2
```
States with highest rates per 100k population are Rhode Island, Alaska, and Kentucky. States with lowest rates per 100k population are Oregon, Maryland, and Maine.

#### c. First five states to experience Covid substantially

```{r, fig.width=8, fig.height=6}
us_states_start <- covid_data %>%
  filter(date > as.Date("2020-03-20"), 
         date < as.Date("2020-04-20"),
         cases_avg_per_100k > 15)

p3 <- ggplot(us_states_start, 
             aes(x = date, y = cases_avg_per_100k, color=state)) +
  geom_line(linewidth = 1.0) + 
  xlim(as.Date("2020-03-20"), as.Date("2020-04-20")) +
  ylim(15, 60) +
  scale_color_brewer(palette = "Spectral") + 
  labs(
    title = "COVID-19 Case Rates by State (Mar â€“ Apr 2020)",
    x = NULL,
    y = "Average Cases per 100k",
    color = "State"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    legend.title.position = "top"
  )

p3
```
First five states to experience Covid substantially are Connecticut, Louisiana, Massachusetts, New Jersey, and New York.


Distribution of sources:

`infer` package: "https://infer.tidymodels.org/articles/t_test.html"

census data: "https://www2.census.gov/programs-surveys/popest/datasets/2020-2023/state/totals/NST-EST2023-ALLDATA.csv"